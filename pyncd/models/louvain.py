# -*- coding: utf-8 -*-
"""Louvain Community Detector.
Reference implementation: https://github.com/networkx/networkx/blob/main/networkx/algorithms/community/louvain.py
"""
# Author: Bocong Deng <bocongdeng@gmail.com>
# License: BSD 2 clause


import networkx as nx
import random
from collections import defaultdict
from networkx.algorithms.community import louvain_partitions
from pyncd.models.base import BaseDetector
from typing import Union, List, Set, Any, Tuple


class LouvainDetector(BaseDetector):
    def __init__(self) -> None:
        super(LouvainDetector, self).__init__()

    def gen_partition(
        self,
        seed: Union[int, None] = None):
        """Wrapper of networkx Louvain with more functionalities.

        Louvain Community Detection Algorithm is a simple method to extract the community
        structure of a network. This is a heuristic method based on modularity optimization.

        The partitions at each level (step of the algorithm) form a dendogram of communities.
        A dendrogram is a diagram representing a tree and each level represents
        a partition of the G graph. The top level contains the smallest communities
        and as you traverse to the bottom of the tree the communities get bigger
        and the overal modularity increases making the partition better.

        Each level is generated by executing the two phases of the Louvain Community
        Detection Algorithm.

        Parameters
        ----------
        G : NetworkX graph
        weight : string or None, optional (default="weight")
        The name of an edge attribute that holds the numerical value
        used as a weight. If None then each edge has weight 1.
        resolution : float, optional (default=1)
            If resolution is less than 1, the algorithm favors larger communities.
            Greater than 1 favors smaller communities
        threshold : float, optional (default=0.0000001)
        Modularity gain threshold for each level. If the gain of modularity
        between 2 levels of the algorithm is less than the given threshold
        then the algorithm stops and returns the resulting communities.
        seed : integer, random_state, or None (default)
        Indicator of random number generation state.
        See :ref:`Randomness<randomness>`.

        seed: int or None, optional (default=None)
            The seed value needed to generate a random number.
        """
        random.seed(seed)
        pass

    def _one_level(
        self,
        graph: Union[nx.Grahp, nx.DiGraph],
        graph_size: int,
        partition: List[Set[Any]],
        weight: Union[str, None] = None,
        resolution: float = 1,
        is_directed: bool = False) -> Tuple[List[Set[Any]], List[Set[Any]], bool]:
        """Calculate one level of the Louvain partitions tree

        Parameters
        ----------
        graph : NetworkX Graph or DiGraph
            The graph from which to detect communities
        graph_size : number
            The size of the graph `graph`.
        partition : list of sets of nodes
            A valid partition of the graph `graph`
        weight: string or None, optional (default=None)
            The name of an edge attribute that holds the numerical value used as a weight.
            If None, then each edge has weight 1.
            The degree is the sum of the edge weights adjacent to the node.
        resolution : positive number
            The resolution parameter for computing the modularity of a partition
        is_directed : bool
            True if `graph` is a directed graph.
        """
        node2com = {node: i for i, node in enumerate(graph.nodes())}
        inner_partition = [{node} for node in graph.nodes()]
        if is_directed:
            in_degrees = dict(graph.in_degree(weight=weight))
            out_degrees = dict(graph.out_degree(weight=weight))
            stot_in = [deg for deg in in_degrees.values()]
            stot_out = [deg for deg in out_degrees.values()]
            # Calculate weights for both in and out neighbours
            neighbours = {}
            for node in graph:
                neighbours[node] = defaultdict(float)
                for _, n, wt in graph.out_edges(node, data=weight):
                    neighbours[node][n] += wt if wt else 1
                for n, _, wt in graph.in_edges(node, data=weight):
                    neighbours[node][n] += wt if wt else 1
        else:
            degrees = dict(graph.degree(weight=weight))
            stot = [deg for deg in degrees.values()]
            neighbours = {node: {v: data.get(weight, 1) for v, data in graph[node].items() if v != node} for node in graph}
        rand_nodes = list(graph.nodes)
        random.shuffle(rand_nodes)
        nb_moves = 1
        improvement = False
        while nb_moves > 0:
            nb_moves = 0
            for node in rand_nodes:
                best_mod = 0
                best_com = node2com[node]
                
                # Calculate weights between node and its neighbor communities.
                weights2com = defaultdict(float)
                for nbr, wt in neighbours[node].items():
                    weights2com[node2com[nbr]] += wt

                if is_directed:
                    in_degree = in_degrees[node]
                    out_degree = out_degrees[node]
                    stot_in[best_com] -= in_degree
                    stot_out[best_com] -= out_degree
                    remove_cost = (
                        -weights2com[best_com] / graph_size
                        + resolution
                        * (out_degree * stot_in[best_com] + in_degree * stot_out[best_com])
                        / graph_size**2
                    )
                else:
                    degree = degrees[node]
                    stot[best_com] -= degree
                    remove_cost = -weights2com[best_com] / graph_size + resolution * (stot[best_com] * degree) / (2 * graph_size**2)
                for nbr_com, wt in weights2com.items():
                    if is_directed:
                        gain = (
                            remove_cost
                            + wt / graph_size
                            - resolution
                            * (
                                out_degree * stot_in[nbr_com]
                                + in_degree * stot_out[nbr_com]
                            )
                            / graph_size**2
                        )
                    else:
                        gain = (remove_cost + wt / graph_size - resolution * (stot[nbr_com] * degree) / (2 * graph_size**2))
                    if gain > best_mod:
                        best_mod = gain
                        best_com = nbr_com
                if is_directed:
                    stot_in[best_com] += in_degree
                    stot_out[best_com] += out_degree
                else:
                    stot[best_com] += degree
                if best_com != node2com[node]:
                    com = graph.nodes[node].get("nodes", {node})
                    partition[node2com[node]].difference_update(com)
                    inner_partition[node2com[node]].remove(node)
                    partition[best_com].update(com)
                    inner_partition[best_com].add(node)
                    improvement = True
                    nb_moves += 1
                    node2com[node] = best_com
        partition = list(filter(len, partition))
        inner_partition = list(filter(len, inner_partition))
        return partition, inner_partition, improvement


